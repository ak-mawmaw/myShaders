<!DOCTYPE html>
<html>

<head>
	<title> Lambertian Shader!</title>
</head>

<body>
	<div id="container"></div>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/106/three.js"></script>
	<script id="vertexShader" type="x-shader/x-vertex">
		varying vec4 globalNorm;
		varying vec4 globalPos;
		void main() {
		globalNorm = modelViewMatrix * (vec4(normal, 0));
		globalPos = modelViewMatrix * vec4(position, 1);
		gl_Position = projectionMatrix * globalPos;
	}
</script>
<script id="fragmentShader" type="x-shader/x-fragment">
	/* *** Implemmentation of rendering algorithm from https://repo-sam.inria.fr/fungraph/deep-materials/
	SupplementalMaterial_Single-Image_SVBRDF_Browser/PseudoCode.pdf  *** */

	precision mediump float;	
	varying vec4 globalNorm;
	varying vec4 globalPos;
	uniform vec2 u_resolution;
	uniform vec3 u_ambient;
	uniform vec3 u_diffuse;
	uniform vec3 u_specular;
	
	#define PI 3.14159265359
	
	//half vector computation
	

	//diffuse contribution scaling
	vec3 diff_scaling(in vec3 d, in vec3 s){
	return d * (1. - s) / PI;
}

//  quick square function
float pow2 (const in float a){
	return a * a;
}


// Cook Torrance normal distribution
float distribute(in float dotNH, in float r){
	return 1./PI * pow2((pow2(r) / pow2(dotNH) * (pow2(r) * pow2(r) - 1.)) + 1.);
}

//shadowing and masking terms
float shadow(in vec4 Wl, in vec4 Wv, in vec4 norm, in float r){
	return 1./(dot(Wl, norm) * (1. - pow2(r)/2. + pow2(r)/2.))  * 1./(dot(Wv , norm) *  (1. - pow2(r)/2. + pow2(r)/2.));
}


//Schlick approximation  https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderChunk/bsdfs.glsl.js
vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {


	/* 
	Optimized variant (presented by Epic at SIGGRAPH '13)
	https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
	*/

	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
	return ( 1.0 - specularColor ) * fresnel + specularColor;
}


// Final rendering
vec3 Final(in vec3 F , in float G, in float D, in float dotNL, in vec3 L ){

	return (F*G*D * 0.25 + D) * (dotNL / cos(L));
}

void main(){ 
	vec4 N = normalize(globalNorm);
	vec4 V = normalize (vec4(cameraPosition, 1.));
	//vec4 L = normalize(vec4(20., 30., 30., 1.));
	vec4 L = normalize(vec4(cameraPosition, 1.) - globalPos);
	vec4 H = normalize((N + L) * 0.5);
	//vec4 H = normalize((N + L) / length(N + L));
	vec3 u_diffuse = vec3(0., 0., 1.);
	vec3 u_specular = vec3(1., 1., 1.);
	vec3 u_ambient = vec3(.0, 1., .0);

	float r =  0.745;
	float dotNH = dot (N, H);
	float dotLH = dot(L, H);
	float dotNL = dot(N, L);

	vec3 d = diff_scaling(u_diffuse, u_specular);
	float D = distribute(dotNH, r);
	float G = shadow(L, V, N, r);
	vec3 F = F_Schlick(u_specular, dotLH);


	vec3 color = Final(F, G, D, dotNL, L.xyz);
	

	gl_FragColor = vec4(color, 1.);
}	
</script>
<script>
	var container;
	var camera, scene, renderer;
	var uniforms, mesh;
	init();
	animate();
	function init() {
		container = document.getElementById('container');
		camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
		camera.position.z = 10;
		camera.lookAt(0,0,0)
		scene = new THREE.Scene();
		//var geometry = new THREE.SphereBufferGeometry(2, 32, 32);
		var geometry = new THREE.BoxGeometry(2,3,3);
		uniforms = {
			u_time: { type: "f", value: 1.0 },
			u_resolution: { type: "v2", value: new THREE.Vector2() },
			u_mouse: { type: "v2", value: new THREE.Vector2()},
			u_ambient: {type : "v3", value: new THREE.Vector3()},
			u_diffuse: {type : "v3", value: new THREE.Vector3()},
			u_specular: {type : "v3", value: new THREE.Vector3()}
		};
		var material = new THREE.ShaderMaterial({
			uniforms: uniforms,
			vertexShader: document.getElementById('vertexShader').textContent,
			fragmentShader: document.getElementById('fragmentShader').textContent
		});
			//let basic = new THREE.MeshBasicMaterial();
			/** LIGHTS!!! **/
			// let light = new THREE.DirectionalLight(0xffff3f, 0,5);
			// light.position = new THREE.Vector3(1,1,0);
			// scene.add(light);
			// let helper = new THREE.DirectionalLightHelper(light, 5);
			// scene.add(helper);
			mesh = new THREE.Mesh(geometry, material);
			scene.add(mesh);
			renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			container.appendChild(renderer.domElement);
			onWindowResize();
			window.addEventListener('resize', onWindowResize, false);
			document.onmousemove = function (e) {
				uniforms.u_mouse.value.x = e.pageX
				uniforms.u_mouse.value.y = e.pageY
			}
		}
		function onWindowResize(event) {
			renderer.setSize(window.innerWidth, window.innerHeight);
			uniforms.u_resolution.value.x = renderer.domElement.width;
			uniforms.u_resolution.value.y = renderer.domElement.height;
		}
		function animate() {
			requestAnimationFrame(animate);
			render();
			mesh.rotation.x += 0.01;
			mesh.rotation.y += 0.01;
		}
		function render() {
			uniforms.u_time.value += 0.05;
			renderer.render(scene, camera);
		}
	</script>
</body>

</html>
