<!DOCTYPE html>
<html>

<head>
	<title> Lambertian Shader!</title>
</head>

<body>
	<div id="container"></div>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/106/three.js"></script>
	<script type="text/javascript" src="/Users/mawuli.a/node_modules/dat.gui/build/dat.gui.min.js 
	"></script> 
	<script id="vertexShader" type="x-shader/x-vertex">
		varying vec4 globalNorm;
		varying vec4 globalPos;
		void main() {
		globalNorm = modelViewMatrix * (vec4(normal, 0));
		globalPos = modelViewMatrix * vec4(position, 1);
		gl_Position = projectionMatrix * globalPos;
	}
</script>
	<script id="fragmentShader" type="x-shader/x-fragment">
	/* *** Implementation of rendering algorithm from https://repo-sam.inria.fr/fungraph/deep-materials/
	SupplementalMaterial_Single-Image_SVBRDF_Browser/PseudoCode.pdf  *** */

	precision mediump float;	
	varying vec4 globalNorm;
	varying vec4 globalPos;
	uniform vec2 u_resolution;
	uniform vec3 u_ambient;
	uniform vec3 u_diffuse;
	uniform vec3 u_specular;
	uniform vec3 u_light;
	
	#define PI 3.14159265359
	
	
	

		//diffuse contribution scaling
		vec3 diff_scaling(in vec3 d, in vec3 s){
		return d * (1. - s) / PI;
	}

	//  quick square function
	float pow2 (const in float a){
	return a * a;
	}


	// Cook Torrance normal distribution
	float distribute(in float dotNH, in float r){
	return 1./PI * pow2((pow2(r) / pow2(dotNH) * (pow2(r) * pow2(r) - 1.)) + 1.);
	}

	//shadowing and masking terms
	float shadow(in vec4 Wl, in vec4 Wv, in vec4 norm, in float r){
	return 1./(dot(Wl, norm) * (1. - pow2(r)/2. + pow2(r)/2.))  * 1./(dot(Wv , norm) *  (1. - pow2(r)/2. + pow2(r)/2.));
	}


	//Schlick approximation  https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderChunk/bsdfs.glsl.js
	vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {


	/* 
	Optimized variant (presented by Epic at SIGGRAPH '13)
	https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
	*/

	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
	return ( 1.0 - specularColor ) * fresnel + specularColor;
	}


	// Final rendering
	vec3 Final(in vec3 F , in float G, in float D, in float dotNL, in vec3 L ){

	return (F*G*D * 0.25 + D) * (dotNL / cos(L));
	}

	void main(){ 
	vec4 N = normalize(globalNorm);
	vec4 V = normalize (vec4(cameraPosition, 1.));
	vec4 L = normalize(vec4(u_light, 0.));
	//vec4 L = normalize(vec4(cameraPosition, 1.) - globalPos);

	//half vector computation
	vec4 H = normalize((N + L) * 0.5);
	//vec4 H = normalize((N + L) / length(N + L));


	vec3 diffuse = normalize(u_diffuse);
	vec3 specular = normalize(u_specular);
	vec3 ambient = normalize(u_ambient); 

	float r =  0.745;
	float dotNH = max(dot (N, H), 0.);
	float dotLH = max(dot(L, H), 0.);
	float dotNL = max(dot(N, L), 0.);

	vec3 d = diff_scaling(diffuse, specular);
	float D = distribute(dotNH, r);
	float G = shadow(L, V, N, r);
	vec3 F = F_Schlick(specular, dotLH);


	vec3 color = Final(F, G, D, dotNL, L.xyz) ;


	gl_FragColor = vec4(color, 1.);
	}	
</script>
	<script>
		var container;
		var camera, scene, renderer;
		var uniforms, mesh;
		init();
		animate();
		function init() {
			container = document.getElementById('container');


			camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
			camera.position.z = 10;
			camera.lookAt(0, 0, 0)
			scene = new THREE.Scene();
			var geometry = new THREE.SphereBufferGeometry(2, 32, 32);
			//var geometry = new THREE.BoxGeometry(2,3,3);


			uniforms = {
				u_time: { type: "f", value: 1.0 },
				u_resolution: { type: "v2", value: new THREE.Vector2() },
				u_mouse: { type: "v2", value: new THREE.Vector2() },
				u_ambient: { type: "v3", value: new THREE.Vector3(0.234, 0.1, 0.3243) },
				u_diffuse: { type: "v3", value: new THREE.Vector3(0., 0., 1.) },
				u_specular: { type: "v3", value: new THREE.Vector3(1., 1., 1.) },
				u_light: { type: "v3", value: new THREE.Vector4(2., 7., 6.) }
			};


			var material = new THREE.ShaderMaterial({
				uniforms: uniforms,
				vertexShader: document.getElementById('vertexShader').textContent,
				fragmentShader: document.getElementById('fragmentShader').textContent
			});


			// Soccerball Material

			// let texture = new THREE.TextureLoader().load("https://threejsfundamentals.org/threejs/resources/images/wall.jpg");
			// let material = new THREE.MeshPhongMaterial();
			// material.alphaMap({file: ///Users/mawuli.a/Documents/JSFiles/realShaders/Rendering.html});

			//let basic = new THREE.MeshBasicMaterial();
			/** LIGHTS!!! **/
			// let lighter = new THREE.DirectionalLight(0xffff3f, 0,5);
			// lighter.position = new THREE.Vector3(1,1,0);
			// scene.add(lighter);
			// let helper = new THREE.DirectionalLightHelper(lighter, 5);
			// scene.add(helper);


			mesh = new THREE.Mesh(geometry, material);
			scene.add(mesh);
			renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			container.appendChild(renderer.domElement);
			onWindowResize();
			window.addEventListener('resize', onWindowResize, false);
			document.onmousemove = function (e) {
				uniforms.u_mouse.value.x = e.pageX
				uniforms.u_mouse.value.y = e.pageY
			}


			/** DAT.GUI INTERFACE ** */

			let gui = new dat.GUI();

			// let t_light = gui.addFolder("Three Light");
			// t_light.add(lighter.position.value.x, "x", 0, 10).listen();
			// t_light.add(lighter.position.value.y, "y", 0, 10).listen();
			// t_light.add(lighter.position.value.z, "z", 0, 10).listen();


			let light = gui.addFolder("LightPosition");
			light.add(uniforms.u_light.value, "x", 0, 100).listen();
			light.add(uniforms.u_light.value, "y", 0, 100).listen();
			light.add(uniforms.u_light.value, "z", 0, 100).listen();


			let specular = gui.addFolder("Specular Light");
			specular.add(uniforms.u_specular.value, "x", 0, 100).listen();
			specular.add(uniforms.u_specular.value, "y", 0, 100).listen();
			specular.add(uniforms.u_specular.value, "z", 0, 100).listen();


			let diffuse = gui.addFolder("Diffuse Light");
			diffuse.add(uniforms.u_diffuse.value, "x", 0, 100).listen();
			diffuse.add(uniforms.u_diffuse.value, "y", 0, 100).listen();
			diffuse.add(uniforms.u_diffuse.value, "z", 0, 100).listen();
		}
		

		function onWindowResize(event) {
			renderer.setSize(window.innerWidth, window.innerHeight);
			uniforms.u_resolution.value.x = renderer.domElement.width;
			uniforms.u_resolution.value.y = renderer.domElement.height;
		}
		function animate() {
			requestAnimationFrame(animate);
			render();
			mesh.rotation.x += 0.01;
			mesh.rotation.y += 0.01;
		}
		function render() {
			uniforms.u_time.value += 0.05;
			renderer.render(scene, camera);
		}
	</script>
</body>

</html>